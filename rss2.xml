<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Maxxice blog</title>
    <link>https://blog.futuredream.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="true" rel="hub"/>
    <description>java springBoot springCloud</description>
    <pubDate>Tue, 05 Dec 2017 13:05:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>springBoot配置drools规则引擎</title>
      <link>https://blog.futuredream.top/2017/12/04/drools1/</link>
      <guid>https://blog.futuredream.top/2017/12/04/drools1/</guid>
      <pubDate>Mon, 04 Dec 2017 12:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Drools 是用 Java 语言编写的开放源码规则引擎，使用 Rete 算法（参阅 参考资料）对所编写的规则求值。Drools 允许使用声
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Drools 是用 Java 语言编写的开放源码规则引擎，使用 Rete 算法（参阅 参考资料）对所编写的规则求值。Drools 允许使用声明方式表达业务逻辑。可以使用非 XML 的本地语言编写规则，从而便于学习和理解。并且，还可以将 Java 代码直接嵌入到规则文件中，这令 Drools 的学习更加吸引人。Drools 还具有其他优点：</p><ul><li>非常活跃的社区支持</li><li>易用</li><li>快速的执行速度</li><li>与 Java Rule Engine API（JSR 94）兼容（参阅 <a href="https://www.ibm.com/developerworks/cn/java/j-drools/index.html#artrelatedtopics" target="_blank" rel="noopener">参考资料</a>）</li><li>免费</li></ul><h2 id="springBoot配置drools规则引擎配置介绍"><a href="#springBoot配置drools规则引擎配置介绍" class="headerlink" title="springBoot配置drools规则引擎配置介绍"></a>springBoot配置drools规则引擎配置介绍</h2><p>关于使用springBoot 配置规则引擎 可以参照以下Demo <a href="https://github.com/tong12580/droolsTest" target="_blank" rel="noopener">GitHub测试地址</a></p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/12/04/drools1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java Money 和 Currency API</title>
      <link>https://blog.futuredream.top/2017/12/01/money1/</link>
      <guid>https://blog.futuredream.top/2017/12/01/money1/</guid>
      <pubDate>Fri, 01 Dec 2017 08:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;JSR 354 - “金钱和货币” 解决了Java中货币和货币金额的标准化问题。&lt;/p&gt;
&lt;p&gt;它的目标是为Java生态系统添加一个灵活的可
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JSR 354 - “金钱和货币” 解决了Java中货币和货币金额的标准化问题。</p><p>它的目标是为Java生态系统添加一个灵活的可扩展的API，并使货币量更简单，更安全。</p><p>JSR没有进入JDK 9，而是未来JDK版本的候选人。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，让我们定义依赖到我们的pom.xml文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javamoney<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>moneta<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>最新版本的依赖关系可以在这里<a href="https://mvnrepository.com/search?q=moneta" target="_blank" rel="noopener">检查</a>。</p><h2 id="JSR-354功能"><a href="#JSR-354功能" class="headerlink" title="JSR-354功能"></a>JSR-354功能</h2><p>“货币和金钱”API的目标：</p><ul><li>提供处理和计算货币金额的API</li><li>定义货币和货币金额的类别，以及货币四舍五入</li><li>处理汇率</li><li>处理货币和货币金额的格式化和解析</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>JSR-354规范的主要类如下图所示：</p><p><img src="/img/context/javax-monetary3-1.png" alt="monetary"></p><p>该模型包含两个主要接口CurrencyUnit 和MonetaryAmount， 在下面的章节中进行了解释。</p><h3 id="1-CurrencyUnit"><a href="#1-CurrencyUnit" class="headerlink" title="1. CurrencyUnit"></a>1. CurrencyUnit</h3><p>CurrencyUnit模拟货币的最小属性。它的实例可以使用Monetary.getCurrency方法获得<br>我们使用货币的字符串表示形式创建CurrencyUnit ，这可能会导致我们尝试使用不存在的代码创建货币的情况。使用不存在的代码创建货币会引发UnknownCurrency异常。</p><h3 id="2-MonetaryAmount"><a href="#2-MonetaryAmount" class="headerlink" title="2. MonetaryAmount"></a>2. MonetaryAmount</h3><p>MonetaryAmount是货币金额的数字表示。它始终与CurrencyUnit 关联，并定义货币的货币表示形式。</p><p>金额可以用不同的方式来实现，重点放在由每个具体用例所定义的货币表示要求的行为上。例如。Money和FastMoney是MonetaryAmount接口的实现。</p><p>FastMoney实现MONETARYAMOUNT使用长为数字表示，并且比更快的BigDecimal在精度的成本; 它可以在我们需要性能时使用，精度不是问题。</p><p>通用实例可以使用默认工厂创建。</p><p>最后</p><p>你可以通过 本文 <a href="https://github.com/tong12580/money" target="_blank" rel="noopener">Github</a> 上的代码片段查询实例的使用方法。</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/12/01/money1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql索引命中分析</title>
      <link>https://blog.futuredream.top/2017/11/30/mysqlIndex1/</link>
      <guid>https://blog.futuredream.top/2017/11/30/mysqlIndex1/</guid>
      <pubDate>Thu, 30 Nov 2017 14:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;在关系型数据库中，索引的存在可以极大的提升关系型数据的查询效率。在mysql中，索引分为聚簇索引和非聚簇索引。&lt;/p&gt;
&lt;h3 id=&quot;聚集
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在关系型数据库中，索引的存在可以极大的提升关系型数据的查询效率。在mysql中，索引分为聚簇索引和非聚簇索引。</p><h3 id="聚集规则"><a href="#聚集规则" class="headerlink" title="聚集规则"></a>聚集规则</h3><ul><li>聚集规则是：有主键则定义主键索引为聚集索引；</li><li>没有主键则选第一个不允许为NULL的唯一索引；</li><li>还没有就使用innodb的内置rowid为聚集索引。</li></ul><h3 id="索引高度"><a href="#索引高度" class="headerlink" title="索引高度"></a>索引高度</h3><p> mysql的索引无论是聚集索引还是非聚集索引，都是B+树结构。聚集索引的叶子节点存放的是数据，非聚集索引的叶子节点存放的是非聚集索引的key和主键值。B+树的高度为索引的高度。 </p><ul><li>聚集索引的高度决定了根据主键取数据的理论IO次数。根据非聚集索引读取数据的理论IO次数还要加上访问聚集索引的IO次数总和。实际上可能要不了这么多IO。因为索引的分支节点所在的Page因为多次读取会在mysql内存里cache住。 </li><li>mysql的一个block大小默认是16K，可以根据索引列的长度粗略估算索引的高度。</li></ul><h3 id="sql优化依据"><a href="#sql优化依据" class="headerlink" title="sql优化依据"></a>sql优化依据</h3><p>SQL语句中的where条件，使用以上的提取规则，最终都会被提取到Index Key (First Key &amp; Last Key)，Index Filter与Table Filter之中。</p><ul><li>Index First Key，只是用来定位索引的起始范围，因此只在索引第一次Search Path(沿着索引B+树的根节点一直遍历，到索引正确的叶节点位置)时使用，一次判断即可；</li><li>Index Last Key，用来定位索引的终止范围，因此对于起始范围之后读到的每一条索引记录，均需要判断是否已经超过了Index Last Key的范围，若超过，则当前查询结束；</li><li>Index Filter，用于过滤索引查询范围中不满足查询条件的记录，因此对于索引范围中的每一条记录，均需要与Index Filter进行对比，若不满足Index Filter则直接丢弃，继续读取索引下一条记录；</li><li>Table Filter，则是最后一道where条件的防线，用于过滤通过前面索引的层层考验的记录，此时的记录已经满足了Index First Key与Index Last Key构成的范围，并且满足Index Filter的条件，回表读取了完整的记录，判断完整记录是否满足Table Filter中的查询条件，同样的，若不满足，跳过当前记录，继续读取索引的下一条记录，若满足，则返回记录，此记录满足了where的所有条件，可以返回给前端用户</li></ul><h2 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h2><p>一条sql语句要执行完成需要经历什么样的过程？<br>当一条sql语句提交给mysql数据库进行查询的时候需要经历以下几步 ：</p><ul><li>先在where解析这一步把当前的查询语句中的查询条件分解成每一个独立的条件单元 </li><li>mysql会自动将sql拆分重组 </li><li>然后where条件会在B-tree index这部分进行索引匹配，如果命中索引，就会定位到指定的table records位置。如果没有命中，则只能采用全部扫描的方式</li><li>根据当前查询字段返回对应的数据值 </li></ul><h2 id="命中判断"><a href="#命中判断" class="headerlink" title="命中判断"></a>命中判断</h2><p>MySql中是通过 <strong>Explain</strong> 命令来分析低效SQL的执行计划。命令的使用很简单.</p><p>首先，我们定义表结构并录入数据，测试表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Table structure for table `history_record` */</span></div><div class="line"></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`history_record`</span>;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`history_record`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'历史记录表'</span>,</div><div class="line">  <span class="string">`imei`</span> <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'设备唯一标识'</span>,</div><div class="line">  <span class="string">`longitude`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'经度'</span>,</div><div class="line">  <span class="string">`lat`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'纬度'</span>,</div><div class="line">  <span class="string">`peroid`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'50'</span> <span class="keyword">COMMENT</span> <span class="string">'显示历史记录时间段'</span>,</div><div class="line">  <span class="string">`status`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</div><div class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</div><div class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</div></pre></td></tr></table></figure><p>我选取最近项目中使用的设备地理位置经纬度历史记录表进行测试分析。</p><p>使用 Explain命令进行分析操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * from test_watch.history_record；</div></pre></td></tr></table></figure><p>执行结果如图所示：</p><p><img src="/img/context/EXPLAIN.png" alt="EXPLAIN"></p><p>执行的每列结果说明：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">含义</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">select_type</td><td style="text-align:center">查询类型</td><td>查询类型，常见的值SIMPLE：简单表，不使用表连接或子查询。PRIMARY : 主查询，外层的查询。UNION 第二个或者后面的查询语句。SUBQUERY : 子查询中的第一个select</td></tr><tr><td style="text-align:left">table</td><td style="text-align:center">输出结果的表</td><td>—</td></tr><tr><td style="text-align:left">type</td><td style="text-align:center">表示MySql在表中找到所需行的方式，或者叫访问类型。</td><td>常见的类型：ALL index rangeEXPLAIN.png ref eq_ref const system NULL 从左到右，性能由最差到最好。 下见详细解读</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:center">可能使用的索引列表</td><td>—</td></tr><tr><td style="text-align:left">key</td><td style="text-align:center">实现执行使用索引列表</td><td>—</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:center">索引的长度</td><td>—</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:center">显示使用哪个列或常数与key一起从表中选择行。</td><td>—</td></tr><tr><td style="text-align:left">row</td><td style="text-align:center">执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引</td><td>—</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:center">过滤</td><td>—</td></tr><tr><td style="text-align:left">Extra</td><td style="text-align:center">该列包含MySQL解决查询的详细信息</td><td>见下文详细解读</td></tr></tbody></table><h3 id="type-详细解读"><a href="#type-详细解读" class="headerlink" title="type 详细解读"></a>type 详细解读</h3><ol><li>type＝ALL　全表扫描 </li><li>type＝index 索引全扫描，遍历整个索引来查询匹配的行</li><li>type=range 索引范围扫描，常见于　&lt;,&lt;=,&gt;,&gt;=,between,in等操作符。例如<ul><li>explain select * from adminlog where id&gt;0 , </li><li>explain select * from adminlog where id&gt;0 and id&lt;=100</li><li>explain select * from adminlog where id in (1,2) </li></ul></li><li>type=ref　使用非唯一索引或唯一索引的前缀扫描，返回匹配某个单独值的记录行。ref还经常出现在JOIN操作中</li><li>type=eq_ref 类似于ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中有一条记录匹配；简单来说，说是多表连接中使用　主建或唯一健作为关联条件</li><li>type=const/system 单表中最多有一个匹配行。主要用于比较primary key [主键索引]或者unique[唯一]索引,因为数据都是唯一的，所以性能最优。条件使用=。 </li><li>type=NULL　不用访问表或者索引，直接就能够得到结果 例如 EXPLAIN SELECT 1 from history_record;,类型type 还有其他值<ul><li>ref_or_null : 与ref 类似，区别在于条件中包含对NULL的查询</li><li>index_merge : 索引合并优化</li><li>unique_subquery : in的后面是一个主键字段的子查询</li><li>ndex_subquery : 与unique_subquery 类似,区别在于in的后面是查询非唯一索引字段的子查询</li></ul></li></ol><h3 id="Extra-详细解读"><a href="#Extra-详细解读" class="headerlink" title="Extra 详细解读"></a>Extra 详细解读</h3><ol><li>Not exists 没有找到合适的索引 </li><li>using index 只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的信息。就是建议取索引列。这样就可以不要通过索引去实际表中找数据了。直接返回索引列的数据。一次查询。否则就是索引表查一次，实际表中查一次。</li><li>using temporary 为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。</li></ol><h2 id="无效索引"><a href="#无效索引" class="headerlink" title="无效索引"></a>无效索引</h2><p>数据变化不大的列。如某类型，是否有效，项目ID等列的索引都是无效的。这些无效索引还是影响Insert 、Update、Delete 语句的性能。因为这些语包的执行都要对索引表进行更新。又因为这些表的值变化不大，数据库很难为他们合理分配索引。所以影响语句的性能。</p><h3 id="IN-OR-是否会走索引？"><a href="#IN-OR-是否会走索引？" class="headerlink" title="IN,OR 是否会走索引？"></a>IN,OR 是否会走索引？</h3><p>一条SQL会不会走索引一个看条件使用的运算符，另一个看有没有索引。所以SQL会不会走索引和IN.OR,group by 没有关系。</p><p>但是 对于OR 来说， OR前后两个条件都要有索引整个SQL才会使用索引！只要有一个条件没索引那么整个SQL都不使用索引。如果出现OR的一个条件没有索引时，建议使用 union </p><h3 id="不走索引的运算符"><a href="#不走索引的运算符" class="headerlink" title="不走索引的运算符"></a>不走索引的运算符</h3><p>什么运算符不走索引 为  &lt;&gt;,!= 运算符</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/30/mysqlIndex1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【译】Linux概念架构</title>
      <link>https://blog.futuredream.top/2017/11/30/linux1/</link>
      <guid>https://blog.futuredream.top/2017/11/30/linux1/</guid>
      <pubDate>Wed, 29 Nov 2017 19:07:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Linux kernel成功的两个原因：（1）灵活的架构设计使得大量的志愿开发者能够很容易加入到开发过程中；（2）每个子系统（尤其是那些需要改进的）都具备良好的可扩展性。正是这两个原因使得Linux kernel可以不断进化和改进。&lt;/p&gt;
&lt;h2 id=&quot;Linux内核在
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Linux kernel成功的两个原因：（1）灵活的架构设计使得大量的志愿开发者能够很容易加入到开发过程中；（2）每个子系统（尤其是那些需要改进的）都具备良好的可扩展性。正是这两个原因使得Linux kernel可以不断进化和改进。</p><h2 id="Linux内核在整个计算机系统中的位置"><a href="#Linux内核在整个计算机系统中的位置" class="headerlink" title="Linux内核在整个计算机系统中的位置"></a>Linux内核在整个计算机系统中的位置</h2><p>Fig 1 - 计算机系统分层结构</p><blockquote><p>分层结构的原则：the dependencies between subsystems are from the top down: layers pictured near the top depend on lower layers, but subsystems nearer the bottom do not depend on higher layers.</p></blockquote><p>这种子系统之间的依赖性只能是从上到下，也就是在上图中位于顶层的子系统依赖位于底层的子系统，反之则不行。</p><h2 id="内核的作用"><a href="#内核的作用" class="headerlink" title="内核的作用"></a>内核的作用</h2><ol><li>虚拟化(抽象)，将计算机硬件抽象为一台虚拟机，供用户进程(process)使用；进程运行时完全不需要知道硬件是如何工作的，只要调用Linux kernel提供的虚拟接口(virtual interface)即可。</li><li>多任务处理，实际上是多个任务在并行使用计算机硬件资源，内核的任务是仲裁对资源的使用，制造每个进程都以为自己是独占系统的错觉。<br>PS：进程上下文切换就是要换掉程序状态字、换掉页表基地址寄存器的内容、换掉current指向的task_struct实例、换掉PC——&gt;也就换掉了进程打开的文件(通过task_struct的files可以找到)、换掉了进程内存的执行空间(通过task_struct的mem可以找到)；</li></ol><h2 id="Linux内核的整体架构"><a href="#Linux内核的整体架构" class="headerlink" title="Linux内核的整体架构"></a>Linux内核的整体架构</h2><p>Linux内核的整体架构<br>中心系统是Process Scheduler（SCHED）：所有其余的子系统都依赖于Process Scheduler，因为其余子系统都需要阻塞和恢复进程。当一个进程需要等待一个硬件动作完成时，相应子系统会阻塞这个进程；当这个硬件动作完成时，子系统会将这个进程恢复：这个阻塞和恢复动作都要依赖于Processor Scheduler完成。</p><p>上图中的每一个依赖箭头都有原因：</p><ul><li>Process Scheduler依赖Memory manager：进程恢复执行时，需要依靠Memory Manager分配供它运行的内存。</li><li>IPC子系统依赖于Memory manager：共享内存机制是进程间通信的一种方法，运行两个进程利用同一块共享的内存空间进行信息传递。</li><li>VFS依赖于Network Interface：支持NFS网络文件系统；</li><li>VFS依赖于Memory Manager：支持ramdisk 设备</li><li>memory manager依赖于VFS，因为要支持swapping，可以将暂时不运行的进程换出到磁盘上的swap分区，进入挂起状态。</li></ul><h2 id="高度模块化设计的系统，利于分工合作。"><a href="#高度模块化设计的系统，利于分工合作。" class="headerlink" title="高度模块化设计的系统，利于分工合作。"></a>高度模块化设计的系统，利于分工合作。</h2><ol><li>只有极少数的程序员需要横跨多个模块开展工作，这种情况确实会发生，仅发生在当前系统需要依赖另一个子系统时；</li><li>硬件设备驱动（hardware device drivers）、文件系统模块（logical filesystem modules）、网络设备驱动（network device drivers）和网络协议模块（network protocol modules）这四个模块的可扩展性最高。</li></ol><h2 id="系统中的数据结构"><a href="#系统中的数据结构" class="headerlink" title="系统中的数据结构"></a>系统中的数据结构</h2><ol><li><p>Task List<br>Process Scheduler 针对每个进程维护一个数据结构task_struct；所有的进程用链表管理，形成task list；process scheduler还维护一个current指针指向当前正在占用CPU的进程。</p></li><li><p>Memory Map<br>Memory Manager存储每个进程的虚拟地址到物理地址的映射；并且也提供了如何换出特定的页，或者是如何进行缺页处理。这些信息存放在数据结构mm_struct中。每个进程都有一个mm_struct结构，在进程的task_struct结构中有一个指针mm指向次进程的mm_struct结构。<br>在mm_struct中有一个指针pgd，指向该进程的页目录表（即存放页目录首地址）——&gt;当该进程被调度时，此指针被换成物理地址，写入控制寄存器CR3(x86体系结构下的页基址寄存器)</p></li><li><p>I-nodes<br>VFS通过inodes节点表示磁盘上的文件镜像，inodes用于记录文件的物理属性。每个进程都有一个files_struct结构，用于表示该进程打开的文件，在task_struct中有个files指针。使用inodes节点可以实现文件共享。文件共享有两种方式：（1）通过同一个系统打开文件file指向同一个inodes节点，这种情况发生于父子进程间；（2）通过不同系统打开文件指向同一个inode节点，举例有硬链接；或者是两个不相关的指针打开同一个文件。</p></li><li><p>Data Connection<br>内核中所有的数据结构的根都在Process Scheduler维护的task list链表中。系统中每个进程的的数据结构task_struct中有一个指针mm指向它的内存映射信息；也有一个指针files指向它打开的文件（用户打开文件表）；还有一个指针指向该进程打开的网络套接字。</p></li></ol><h2 id="子系统架构"><a href="#子系统架构" class="headerlink" title="子系统架构"></a>子系统架构</h2><h3 id="Process-Scheduler-架构"><a href="#Process-Scheduler-架构" class="headerlink" title="Process Scheduler 架构"></a>Process Scheduler 架构</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>process scheduler是Linux kernel中最重要的子系统。系统通过它来控制对CPU的访问——不仅仅是用户进程对CPU的访问，也包括其余子系统对CPU的访问。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>进程调度器<br>调度策略模块(scheduling policy module)：决定哪个进程获得对CPU的访问权；调度策略应该让所有进程尽可能公平得共享CPU。</p><ul><li>体系结构相关模块(architecture-specific module)设计一组统一的抽象接口来屏蔽特定体系接口芯片的硬件细节。这个模块与CPU交互以阻塞和恢复进程。这些操作包括获取每个进程需要保存的寄存器和状态信息、执行汇编代码来完成阻塞或者恢复操作。</li><li>体系结构无关模块(architecture-independent module) 与调度策略模块交互将决定下一个执行的进程，然后调用体系结构相关的代码去恢复那个进程的执行。不仅如此，这个模块还会调用memory manager的接口来确保被阻塞的进程的内存映射信息被正确得保存起来。</li><li>系统调用接口模块(system call interface) 允许用户进程访问Linux Kernel明确暴露给用户进程的资源。通过一组定义合适的基本上不变的接口（POSIX标准），将用户应用程序和Linux内核解耦，使得用户进程不会受到内核变化的影响。</li></ul><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>调度器维护一个数据结构——task list，其中的元素时每个活动的进程task_struct实例；这个数据结构不仅仅包含用来阻塞和恢复进程的信息，也包含额外的计数和状态信息。这个数据结构在整个kernel层都可以公共访问。</p><h3 id="依赖关系、数据流、控制流"><a href="#依赖关系、数据流、控制流" class="headerlink" title="依赖关系、数据流、控制流"></a>依赖关系、数据流、控制流</h3><p>正如前面提到过的，调度器需要调用memory manager提供的功能，去为需要恢复执行的进程选择合适的物理地址，正因为如此，所以Process Scheuler子系统依赖于内存管理子系统。当其他内核子系统需要等待硬件请求完成时，它们都依赖于进程调度子系统进行进程的阻塞和恢复。这种依赖性通过函数调用和访问共享的task list数据结构来体现。所有的内核子系统都要读或者写代表当前正在运行进程的数据结构，因此形成了贯穿整个系统的双向数据流。</p><p>除了内核层的数据流和控制流，OS服务层还给用户进程提供注册定时器的接口。这形成了由调度器对用户进程的控制流。通常唤醒睡眠进程的用例不在正常的控制流范围，因为用户进程无法预知何时被唤醒。最后，调度器与CPU交互来阻塞和恢复进程，这又形成它们之间的数据流和控制流——CPU负责打断当前正在运行的进程，并允许内核调度其他的进程运行。</p><h2 id="Memory-Manager-架构"><a href="#Memory-Manager-架构" class="headerlink" title="Memory Manager 架构"></a>Memory Manager 架构</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>内存管理模块负责控制进程如何访问物理内存资源。通过硬件内存管理系统（MMU）管理进程虚拟内存和机器物理内存之间的映射。每一个进程都有自己独立的虚拟内存空间，所以两个进程可能有相同的虚拟地址，但是它们实际上在不同的物理内存区域运行。MMU提供内存保护，让两个进程的物理内存空间不互相干扰。内存管理模块还支持swap——将暂时不用的内存页换出到磁盘上的swap分区，这种技术让进程的虚拟地址空间大于物理内存的大小。虚拟地址空间的大小由机器字长决定。</p><h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><p>内存管理子系统</p><ul><li>架构相关模块(architecture specific module)提供访问物理内存的虚拟接口；</li><li>架构无关模块(architecture independent module)负责每个进程的地址映射以及虚拟内存交换。当发生缺页错误时，由该模块负责决定哪个内存页应该被换出内存——因为这个内存页换出选择算法几乎不需要改动，所以这里没有建立一个独立的策略模块。</li><li>系统调用接口(system call interface) 为用户进程提供严格的访问接口（malloc和free；mmap和ummap）。这个模块允许用进程分配和释放内存、执行内存映射文件操作</li></ul><h3 id="数据表示-1"><a href="#数据表示-1" class="headerlink" title="数据表示"></a>数据表示</h3><p>内存管理存放每个进程的虚拟内存到物理内存的映射信息。这种映射信息存放在mm_struct结构实例中，这个实例的指针又存放在每个进程的task_struct中。除了存放映射信息，数据块中还应该存放关于内存管理器如何获取和存储页的信息。例如：可执行代码能够将可执行镜像作为备份存储；但是动态申请的数据则必须备份到系统页中。（这个没看懂，请高手解惑？）<br>最后，内存管理模块还应该存放访问和技术信息，以保证系统的安全。</p><h3 id="依赖关系、数据流和控制流"><a href="#依赖关系、数据流和控制流" class="headerlink" title="依赖关系、数据流和控制流"></a>依赖关系、数据流和控制流</h3><p>内存管理器控制物理内存，当page fault发生时，接受硬件的通知（缺页中断）—— 这意味着在内存管理模块和内存管理硬件之间存在双向的数据流和控制流。内存管理也依赖文件系统来支持swapping和内存映射I/O——这种需求意味着内存管理器需要调用对文件系统提供的函数接口(procedure calls)，往磁盘中存放内存页和从磁盘中取内存页。因为文件系统请求非常慢，所以在等待内存页被换入之前，内存管理器要让进程需要进入休眠——这种需求让内存管理器调用process scheduler的接口。由于每个进程的内存映射存放在进程调度器的数据结构中，所以在内存管理器和进程调度器之间也有双向的数据流和控制流。用户进程可以建立新的进程地址空间，并且能够感知缺页错误——这里需要来自内存管理器的控制流。一般来说没有用户进程到内存管理器的数据流，但是用户进程却可以通过select系统调用，从内存管理器获取一些信息。</p><h2 id="Virtual-File-System-架构"><a href="#Virtual-File-System-架构" class="headerlink" title="Virtual File System 架构"></a>Virtual File System 架构</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>虚拟文件系统为存储在硬件设备上数据提供统一的访问接口。可以兼容不同的文件系统（ext2,ext4,ntf等等）。计算机中几乎所有的硬件设备都被表示为一个通用的设备驱动接口。逻辑文件系统促进与其他操作系统标准的兼容性，并且允许开发者以不同的策略实现文件系统。虚拟文件系统更进一步，允许系统管理员在任何设备上挂载任何逻辑文件系统。虚拟文件系统封装物理设备和逻辑文件系统的细节，并且允许用户进程使用统一的接口访问文件。</p><p>除了传统的文件系统目标，VFS也负责装载新的可执行文件。这个任务由逻辑文件系统模块完成，使得Linux可以支持多种可执行文件。</p><h3 id="模块-2"><a href="#模块-2" class="headerlink" title="模块"></a>模块</h3><p>虚拟文件系统模块</p><ul><li>设备驱动模块（device driver module）</li><li>设备独立接口模块（Device Independent Interface）：提供所有设备的同一视图</li><li>逻辑文件系统（logical file system）：针对每种支持的文件系统</li><li>系统独立接口（system independent interface）提供硬件资源和逻辑文件系统都无关的接口，这个模块通过块设备节点或者字符设备节点提供所有的资源。</li><li>系统调用模块（system call interface）提供用户进程对文件系统的统一控制访问。虚拟文件系统为用户进程屏蔽了所有特殊的特性。</li></ul><h3 id="数据表示-2"><a href="#数据表示-2" class="headerlink" title="数据表示"></a>数据表示</h3><p>所有文件使用i-nodes表示。每个inode都记录一个文件在硬件设备上的位置信息。不仅如此，inode还存放着指向逻辑文件系统模块和设备驱动的的函数指针，这些指针能够执行具体的读写操作。通过按照这种形式（就是面向对象中的虚函数的思想）存放函数指针，具体的逻辑文件系统和设备驱动可以向内核注册自己而不需要内核依赖具体的模块特性。</p><h3 id="依赖关系、数据流和控制流-1"><a href="#依赖关系、数据流和控制流-1" class="headerlink" title="依赖关系、数据流和控制流"></a>依赖关系、数据流和控制流</h3><p>一个特殊的设备驱动是ramdisk，这个设备在主存中开辟一片区域，并把它当成持久性存储设备使用。这个设备驱动使用内存管理模块完成任务，所以在VFS与对内存管理模块存在依赖关系（图中的依赖关系反了，应该是VFS依赖于内存管理模块）、数据流和控制流。</p><p>逻辑文件系统支持网络文件系统。这个文件系统像访问本地文件一样，从另一台机器上访问文件。为了实现这个功能，一种逻辑文件系统通过网络子系统完成它的任务——这引入了VFS对网络子系统的一个依赖关系以及它们之间的控制流和数据流。</p><p>正如前面提到的，内存管理器使用VFS完成内存swap功能和内存映射I/O。另外，当VFS等待硬件请求完成时，VFS需要使用进程调度器阻塞进程；当请求完成时，VFS需要通过进程调度器唤醒进程。最后，系统调用接口允许用户进程调用来存取数据。不像前面的子系统，VFS没有提供给用户注册不明确调用的机制，所以没有从VFS到用户进程的控制流。</p><h2 id="Network-Interface-架构"><a href="#Network-Interface-架构" class="headerlink" title="Network Interface 架构"></a>Network Interface 架构</h2><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>网络子系统让Linux系统能够通过网络与其他系统相连。这个子系统支持很多硬件设备，也支持很多网络协议。网络子系统将硬件和协议的实现细节都屏蔽掉，并抽象出简单易用的接口供用户进程和其他子系统使用——用户进程和其余子系统不需要知道硬件设备和协议的细节。</p><h3 id="模块-3"><a href="#模块-3" class="headerlink" title="模块"></a>模块</h3><p>网络协议层模块图</p><ul><li>网络设备驱动模块（network device drivers）<br>设备独立接口模块（device independent interface module）提供所有硬件设备的一致访问接口，使得高层子系统不需要知道硬件的细节信息。</li><li>网络协议模块（network protocol modules）负责实现每一个网络传输协议，例如：TCP，UDP，IP，HTTP，ARP等等~</li><li>协议无关模块（protocol independent interface）提供独立于具体协议和具体硬件设备的一致性接口。这使得其余内核子系统无需依赖特定的协议或者设备就能访问网络。</li><li>系统调用接口模块（system calls interface）规定了用户进程可以访问的网络编程API</li></ul><h3 id="数据表示-3"><a href="#数据表示-3" class="headerlink" title="数据表示"></a>数据表示</h3><p>每个网络对象都被表示为一个套接字（socket）。套接字与进程关联的方法和i-nodes节点相同。通过两个task_struct指向同一个套接字，套接字可以被多个进程共享。</p><h3 id="数据流，控制流和依赖关系"><a href="#数据流，控制流和依赖关系" class="headerlink" title="数据流，控制流和依赖关系"></a>数据流，控制流和依赖关系</h3><p>当网络子系统需要等待硬件请求完成时，它需要通过进程调度系统将进程阻塞和唤醒——这形成了网络子系统和进程调度子系统之间的控制流和数据流。不仅如此，虚拟文件系统通过网络子系统实现网络文件系统（NFS）——这形成了VFS和网络子系统指甲的数据流和控制流。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1、Linux内核是整个Linux系统中的一层。内核从概念上由五个主要的子系统构成：进程调度器模块、内存管理模块、虚拟文件系统、网络接口模块和进程间通信模块。这些模块之间通过函数调用和共享数据结构进行数据交互。、</p><p>2、Linux内核架构促进了他的成功，这种架构使得大量的志愿开发人员可以合适得分工合作，并且使得各个特定的模块便于扩展。</p><ul><li>可扩展性一：Linux架构通过一项数据抽象技术使得这些子系统成为可扩展的——每个具体的硬件设备驱动都实现为单独的模块，该模块支持内核提供的统一的接口。通过这种方式，个人开发者只需要和其他内核开发者做最少的交互，就可以为Linux内核添加新的设备驱动。</li><li>可扩展性二：Linux内核支持多种不同的体系结构。在每个子系统中，都将体系结构相关的代码分割出来，形成单独的模块。通过这种方法，一些厂家在推出他们自己的芯片时，他们的内核开发小组只需要重新实现内核中机器相关的代码，就可以讲内核移植到新的芯片上运行。</li></ul><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>1.<a href="http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/intro_softarch.html" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/intro_softarch.html</a><br>2.<a href="http://www.fceia.unr.edu.ar/ingsoft/monroe00.pdf" target="_blank" rel="noopener">http://www.fceia.unr.edu.ar/ingsoft/monroe00.pdf</a><br>3.内核源码：<a href="http://lxr.oss.org.cn/" target="_blank" rel="noopener">http://lxr.oss.org.cn/</a></p><blockquote><p>声明：本文翻译自Conceptual Architecture of the Linux Kernel</p><p>本文链接： <a href="http://www.javadu.site/2017/11/05/Conceptional-Architecture-of-Linux/" target="_blank" rel="noopener">http://www.javadu.site/2017/11/05/Conceptional-Architecture-of-Linux/</a><br>版权声明： 本文章采用 CC BY 4.0 CN协议</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/30/linux1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式之代理模式</title>
      <link>https://blog.futuredream.top/2017/11/27/proxy1/</link>
      <guid>https://blog.futuredream.top/2017/11/27/proxy1/</guid>
      <pubDate>Sun, 26 Nov 2017 23:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;代理模式点解&quot;&gt;&lt;a href=&quot;#代理模式点解&quot; class=&quot;headerlink&quot; title=&quot;代理模式点解&quot;&gt;&lt;/a&gt;代理模式点解&lt;/h3&gt;&lt;p&gt;代理模式对于技术人员来说是最常见的设计模式了吧。现实应用中对于代理模式的应用，比如我们熟知的Nginx,&lt;b
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="代理模式点解"><a href="#代理模式点解" class="headerlink" title="代理模式点解"></a>代理模式点解</h3><p>代理模式对于技术人员来说是最常见的设计模式了吧。现实应用中对于代理模式的应用，比如我们熟知的Nginx,<br>大名鼎鼎的Socket5。用户通过代理来完成自己当前请求，而不直接访问资源，就像律师，用户不用直接参与诉讼，派出律师参与诉讼的整个环节。</p><p>综上所述，代理模式的好处在于以下几点：</p><ul><li>安全性。在代理模式中，用户与资源之间通过代理访问，供求双方并不直接接触，一定程度上提高了安全性；</li><li>模糊处理细节。类比nginx，使用代理，模糊其中的技术细节，使访问过程变得容易。同时，在这里，代理或许会智能的处理找寻最近的资源反馈给用户；</li><li>延迟加载。类似在对数据库链接查询初始化的操作中，当服务刚刚启动时，因为并没有真正的用户操作，所以只初始化没有任何属性操作的代理类，而非初始化查询类。加快了启动速率。当用户真正去做查询操作时，再由代理了单独去加载真正的查询类，完成用户的请求。</li></ul><p>咱们来举个🌰说明一下</p><p style="text-align:center;"><br>    <img src="/img/context/proxy.png"><br>    <span>图1-代理初始化与访问查询时序图</span><br></p><p> 角色  | 作用<br>|: —:|: — :|<br>user | 用户, 代理类的使用者，命令发出者<br>DBProxy| 数据库代理<br>DBQuery| 数据访问实体</p><p>当用户刚启用服务时，因为并没有真实访问数据库，所以只初始化了数据代理服务，并没有建立数据库连接，减少因建立连接而产生的等待时间。这样是非常快捷并节约资源的。当用户需要数据时，此时用户访问代理，由代理去构建数据访问实例，得到结果并返回给用户。在此过程中，由于是代理去寻找数据资源，而用户并不知道真实资源是从谁那里得到的，因此，更加安全。</p><h2 id="构建一个简单的代理"><a href="#构建一个简单的代理" class="headerlink" title="构建一个简单的代理"></a>构建一个简单的代理</h2><p>基于以上设计，我们来构建一个简单的代理; 首先，我们构造一个数据查询接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDBQuery</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，我们构建一个重量级的实现，来模拟其中的数据资源加载，网络请求等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQuery</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQuery</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再来，我们构建一个快捷的访问代理，同时实现该数据查询接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> DBQuery query = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == query) &#123;</div><div class="line">            query = <span class="keyword">new</span> DBProxy();</div><div class="line">        &#125;</div><div class="line">       <span class="keyword">return</span> query.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们用一个main函数来模拟软件初始化，以及用户访问的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IDBQuery  idbQuery = <span class="keyword">new</span> DBProxy();<span class="comment">//软件初始化，先加载代理。</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">      idbQuery.request();<span class="comment">//用户真正访问时，创建真实数据访问对象。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此实例能较为直观的反应代理的延迟加载作用和机制。当然在java中更多的使用了类似CGLIB，代理工厂等来动态加载代理类，来做到运行时加载，提供系统效率。后面将会慢慢分解。</p><style type="text/css">    p {        text-indent: 2em    }</style>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/27/proxy1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBI -- 简介</title>
      <link>https://blog.futuredream.top/2017/11/21/jdbi/</link>
      <guid>https://blog.futuredream.top/2017/11/21/jdbi/</guid>
      <pubDate>Mon, 20 Nov 2017 19:03:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;五分钟介绍&quot;&gt;&lt;a href=&quot;#五分钟介绍&quot; class=&quot;headerlink&quot; title=&quot;五分钟介绍&quot;&gt;&lt;/a&gt;五分钟介绍&lt;/h3&gt;&lt;p&gt;JDBI是Java的SQL连接处理的便利工具库。它试图以Java中使用集合，bean等来映射关系来访问关系数据库，同
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="五分钟介绍"><a href="#五分钟介绍" class="headerlink" title="五分钟介绍"></a>五分钟介绍</h3><p>JDBI是Java的SQL连接处理的便利工具库。它试图以Java中使用集合，bean等来映射关系来访问关系数据库，同时保持与JDBC相同的粒度。它公开了两种不同风格的API，一种流式风格和一种sql对象风格。</p><h3 id="流式风格的API"><a href="#流式风格的API" class="headerlink" title="流式风格的API"></a>流式风格的API</h3><p>流式风格API 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// using in-memory H2 database</span></div><div class="line">DataSource ds = JdbcConnectionPool.create(<span class="string">"jdbc:h2:mem:test"</span>,</div><div class="line">                                          <span class="string">"username"</span>,</div><div class="line">                                          <span class="string">"password"</span>);</div><div class="line">DBI dbi = <span class="keyword">new</span> DBI(ds);</div><div class="line">Handle h = dbi.open();</div><div class="line">h.execute(<span class="string">"create table something (id int primary key, name varchar(100))"</span>);</div><div class="line"></div><div class="line">h.execute(<span class="string">"insert into something (id, name) values (?, ?)"</span>, <span class="number">1</span>, <span class="string">"Brian"</span>);</div><div class="line"></div><div class="line">String name = h.createQuery(<span class="string">"select name from something where id = :id"</span>)</div><div class="line">                    .bind(<span class="string">"id"</span>, <span class="number">1</span>)</div><div class="line">                    .map(StringMapper.FIRST)</div><div class="line">                    .first();</div><div class="line">                    </div><div class="line">assertThat(name, equalTo(<span class="string">"Brian"</span>));</div><div class="line"></div><div class="line">h.close();</div></pre></td></tr></table></figure><p>DBI对象类似于JDBC数据源，并且通常通过传递JDBC数据源来构造。有参构造函数采取JDBC URL和证书，以及其他手段（密码）。从DBI实例获得Handle实例。Handle表示到数据库的单个连接。Handles处理器们依赖于底层的JDBC连接对象。</p><p>使用处理器Handles，您可以创建和执行语句，查询，调用，批处理或准备好的批处理。在上面的例子中，我们执行一个语句来创建一个表。执行另一个SQL语句时使用两个占位符参数来插入值。最后，我们构造一个查询，将一个值绑定到查询中的命名参数，将结果映射为String类型，并采取回来的第一个结果。</p><p>创建和查询的命名参数设施由JDBI提供，它在实际构建准备好的语句时解析出SQL并使用位置参数。上面的例子使用默认的冒号做分隔器，但也可以使用问号做分割器。其语法类比于使用冒号的数据库，比如PostgreSQL。</p><h3 id="SQL对象风格的API"><a href="#SQL对象风格的API" class="headerlink" title="SQL对象风格的API"></a>SQL对象风格的API</h3><p>第二种，SQL对象风格API简化了创建DAO对象的常见方式，在该方法中，单个方法映射到单个语句。SQL对象定义是一个带注释的接口，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface MyDAO</div><div class="line">&#123;</div><div class="line">  @SqlUpdate(&quot;create table something (id int primary key, name varchar(100))&quot;)</div><div class="line">  void createSomethingTable();</div><div class="line"></div><div class="line">  @SqlUpdate(&quot;insert into something (id, name) values (:id, :name)&quot;)</div><div class="line">  void insert(@Bind(&quot;id&quot;) int id, @Bind(&quot;name&quot;) String name);</div><div class="line"></div><div class="line">  @SqlQuery(&quot;select name from something where id = :id&quot;)</div><div class="line">  String findNameById(@Bind(&quot;id&quot;) int id);</div><div class="line"></div><div class="line">  /**</div><div class="line">   * close with no args is used to close the connection</div><div class="line">   */</div><div class="line">  void close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个接口定义了两个更新语句，其中创建与api示例中相同的创建表相同，第二个更新执行相同的插入，第三个定义查询。在后面的两个例子中，注意使用绑定限制符来对应相应的参数。</p><p>最后的方法close（）是特殊的。当它被调用时，它将关闭底层的JDBC连接。该方法可能被声明为引发异常，例如close（）方法在java.io.Closeable上执行，使其适用于Java 7中的自动资源管理。</p><p>为了使用这个sql对象定义，我们使用这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// using in-memory H2 database via a pooled DataSource</div><div class="line">JdbcConnectionPool ds = JdbcConnectionPool.create(&quot;jdbc:h2:mem:test2&quot;,</div><div class="line">                                                  &quot;username&quot;,</div><div class="line">                                                  &quot;password&quot;);</div><div class="line">DBI dbi = new DBI(ds);</div><div class="line"></div><div class="line">MyDAO dao = dbi.open(MyDAO.class);</div><div class="line"></div><div class="line">dao.createSomethingTable();</div><div class="line"></div><div class="line">dao.insert(2, &quot;Aaron&quot;);</div><div class="line"></div><div class="line">String name = dao.findNameById(2);</div><div class="line"></div><div class="line">assertThat(name, equalTo(&quot;Aaron&quot;));</div><div class="line"></div><div class="line">dao.close();</div><div class="line">ds.dispose();</div></pre></td></tr></table></figure><p>我们从DBI实例中获得一个sql对象的实例，然后调用它的方法。这里有几种不同的方式创建sql对象实例。这里的一个将对象绑定到一个特定的处理器中，所以我们需要确保在完成对象时关闭对象。</p><h3 id="获取JDBI"><a href="#获取JDBI" class="headerlink" title="获取JDBI"></a>获取JDBI</h3><p>JDBI是根据Apache许可证2.0许可的，没有额外的运行时依赖性。</p><p>Maven的<br>要在基于Apache Maven的项目中使用JDBI ，添加它是一个依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jdbi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jdbi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>您可以在<a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jdbi%22" target="_blank" rel="noopener">Maven Central</a>中找到最新版本的JDBI 。</p><h4 id="下载Jar"><a href="#下载Jar" class="headerlink" title="下载Jar"></a>下载Jar</h4><p>JDBI发布jar文件可以从<a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jdbi%22" target="_blank" rel="noopener">Maven Central</a>获得。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>JDBI的主要存储库位于Github上，网址为<a href="http://github.com/brianm/jdbi/" target="_blank" rel="noopener">http://github.com/brianm/jdbi/</a></p><h4 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h4><p>JDBI的邮件列表以<a href="https://groups.google.com/group/jdbi上的Google" target="_blank" rel="noopener">https://groups.google.com/group/jdbi上的Google</a> Group托管</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/21/jdbi/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker mongoDB 单机安装办法</title>
      <link>https://blog.futuredream.top/2017/11/16/docker_one_mongoDB/</link>
      <guid>https://blog.futuredream.top/2017/11/16/docker_one_mongoDB/</guid>
      <pubDate>Wed, 15 Nov 2017 19:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/docker-library/docs/01c126
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="https://raw.githubusercontent.com/docker-library/docs/01c12653951b2fe592c1f93a13b4e289ada0e3a1/mongo/logo.png" alt="这里写图片描述"></p><p>MongoDB（来自“humongous”）是一个跨平台的面向文档的数据库。作为一个NoSQL数据库，MongoDB避开了传统的基于表格的关系数据库结构，而采用动态模式的类似JSON的文档（MongoDB称为BSON格式），使得某些类型的应用程序中的数据集成更加方便快捷。MongoDB是GNU Affero通用公共许可证和Apache许可证的组合，是免费的开源软件。使用Docker安装单机版是比较快捷的办法。</p><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><p>安装办法如下：</p><ul><li>首先，可以打开docker hub 检索mongoDB,搜索你喜欢的MongoDB条目。像我就倾向选择 official 版本，便于拓展或后续操作。</li></ul><p><img src="http://img.blog.csdn.net/20171115093620364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjNva2Vy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>使用 <code>docker pull mongo</code> 来拉取一个docker镜像</li><li><p>使用密码启动服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mongo -p 27017:27017 -v /home/data/mongodb/data(映射为自己的DB数据文件存储位置):/data/db -d mongo --auth</div></pre></td></tr></table></figure></li><li><p>启动之后 <code>docker exec -it some-mongo mongo admin</code> 连接至admin 来添加初始管理员用户，创建数据库，已经赋予权限。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; db.createUser(&#123; user: &apos;jsmith&apos;, pwd: &apos;some-initial-password&apos;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;);(创建 admin用户) </div><div class="line">&gt; db.createUser(&#123;user:&apos;&apos;,pwd:&apos;root&apos;,roles:[&#123; role:&apos;root&apos;,db: &apos;admin&apos;&#125;]&#125;) 创建root用户</div><div class="line">&gt; db.auth(“用户名”,”密码”)给admin账户授权</div><div class="line">&gt; use octblog 数据库</div><div class="line">&gt; db.createUser(&#123;user: &quot;gevin&quot;,pwd: &quot;gevin&quot;,</div><div class="line">  roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;octblog&quot;&#125;,&#123; role: &quot;readWrite&quot;, db: &quot;octblog-log&quot; &#125; ] &#125;)创建普通读写用户</div></pre></td></tr></table></figure><ul><li>这样就可以通过外部访问数据库了</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>MongoDB 权限说明</p><p>　　a MongoDB内置角色官网文档介绍：<a href="http://docs.mongoing.com/manual-zh/reference/built-in-roles.html" target="_blank" rel="noopener">http://docs.mongoing.com/manual-zh/reference/built-in-roles.html</a><br>　　b 关于MongoDB的内置角色，我们大概可以分为以下几种来简单说一下<br>　　　　b.1 Database User Roles(数据库用户角色)：read、readWrite<br>　　　　b.2 Database Administration Roles(数据库管理角色)：dbAdmin、dbOwner、userAdmin<br>　　　　b.3 Culster Administration Roles(管理员组，针对整个系统进行管理)：clusterAdmin、clusterManager、clusterMonitor、hostManager<br>　　　　b.4 Backup and Restoration Roles(备份还原角色组)：backup、restore<br>　　　　b.5 All-Database Roles(所有数据库角色)：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase<br>　　　　b.6 Superuser Roles(超级管理员)：root、(dbOwner、userAdmin、userAdminAnyDatabase这几个角色角色提供了任何数据任何用户的任何权限的能力，拥有这个角色的用户可以在任何数据库上定义它们自己的权限)<br>　　　　b.7  Internal Role(内部角色，一般情况下不建议设置)：__system<br>　　c 关于上面每一个角色的意义是什么，请自行去官网或者这篇文章去查看，地址是：<a href="http://www.cnblogs.com/SamOk/p/5162767.html" target="_blank" rel="noopener">http://www.cnblogs.com/SamOk/p/5162767.html</a></p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/16/docker_one_mongoDB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>格局与视野 -- 工作篇</title>
      <link>https://blog.futuredream.top/2017/11/14/education/</link>
      <guid>https://blog.futuredream.top/2017/11/14/education/</guid>
      <pubDate>Mon, 13 Nov 2017 20:46:25 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;站得高，看得远，说话抓得住重点的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h3&gt;&lt;p&gt;我出道不久，屌丝软件工程师一枚，本文
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>站得高，看得远，说话抓得住重点的。</p></blockquote><h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>我出道不久，屌丝软件工程师一枚，本文就聊聊自己对工作的认识和对职业的看法。经验有限，难免有不周之处，也很希望大家能指出斧正。</p><h3 id="视野与格局"><a href="#视野与格局" class="headerlink" title="视野与格局"></a>视野与格局</h3><p>在看待一个程序员的能力时，我们主要从三个方面来看待，其分别是编码能力、业务能力、协作能力。</p><h4 id="一、编码能力"><a href="#一、编码能力" class="headerlink" title="一、编码能力"></a>一、编码能力</h4><p>编码能力顾名思义就是写代码的能力，它主要体现在 – 基础知识的掌握和灵活运用，代码框架的搭建与使用，对于算法与数据结构的理解和活学活用以及遇到问题的分析处理问题的能力。<br>编程能力越强，就越能解决复杂问题，特别是当对算法有一定的了解掌握，对数据结构有特精通时，就越能避免一些诸如死锁，线程安全，故障快排等问题，并能从数据或算法根源去永远解决问题。同时，你的视野也决定着你的编码能力。如果你经常浏览各种论坛，参与各类开源项目，或者你有去了解过很多开源的技术知识，那么当出现相应的应用场景时，你就会很容易去想到对应的技术。</p><h4 id="二、业务能力"><a href="#二、业务能力" class="headerlink" title="二、业务能力"></a>二、业务能力</h4><p>业务能力其实就是个人经验的一种体验。在不同的业务场景下处理相同数据的方法就有可能是不同的。例如类似黑五购物秒杀。平常的购物由于并发数量有限，可能你需要保证客户所下的每笔订单都能成功交易。可是在秒杀场景，或者抢购场景，你可能就需要应对瞬间的高并发下单场景，但此时每笔订单却不是必须要保证下单成功，那么此时，可能就要做故意丢单，丢包等，一方面限制并发量，一方面确保不超单。那么在此过程中你的业务能力就是需要你的业务积累来确保业务的正常运行。</p><h4 id="三、协作能力"><a href="#三、协作能力" class="headerlink" title="三、协作能力"></a>三、协作能力</h4><p>大部分程序员都不是全栈工程师，就算是全栈也是需要跟产品，需求，UI等进行合作才能完成项目。如何保证几个高手互相能够配合好？如何保证项目里面水平最差的人不拖后腿？这个工程化建设，往往会跨越多个业务，以汇报关系上的团队为单位来做。包括前后端解耦，模块化，质量保证，代码风格等等。 程序员的性格非常的单纯或者简单，对于事情的处理，容易情绪化或者欠缺历练，往往影响个人的职业发展。</p><p>视野解决了人的思维高度，要抓住能和市场，或是业内人士沟通的机会，互相了解，把握各种契机，不要将自己局限在一个狭小的领域。产品／商业／市场等等都是作为一个职场人士需要涉猎的，如果你只是看技术的书籍，你需要谨慎了，自己的视野有可能会被限制了。要有职业规划和设计，发掘自己的职业方向，终身学习和抬头做事，不要想着可以在一个公司终老。</p><p>在谈论玩以上的那些之后，我们也就可以探讨下更高一层的管理与规范，工作与生活方面的心得了。</p><h3 id="管理与规范"><a href="#管理与规范" class="headerlink" title="管理与规范"></a>管理与规范</h3><p>当身处在一个团队，并管理一个团队时，我们可能就会想一下的几个问题：</p><ol><li>如何提高开发效率、如何培养技术团队、如何选拔技术人才、如何建立企业文化?</li><li>如何整合现有资源、如何按标准流程去做事、如何设计系统架构、如何进行异地工作、如何跨团队工作、如何高效沟通?<br>对此，我是有一些建议</li><li>开发团队建立初期，要定义开发规范与流程，培养核心技术人员并分阶段进行改造。</li><li>高效开发。懂得敏捷开发，学习Scrum敏捷开发方式，学习将团队拆分为Scrum小组，Scrum Master快速评估开发量，技术评审，很分配督促开发任务，每日召开stand up并且参与到编码中来，Product Owner来负责整个产品，把控整个业务逻辑。Scrum Team 互相协作完成各项开发和测试任务任务，按照时间与优先级，顺次完成并每日汇总。</li></ol><h3 id="工作与生活"><a href="#工作与生活" class="headerlink" title="工作与生活"></a>工作与生活</h3><p>作为一个程序猿，可能一天不写代码手就会痒又或是为了一个问题可以废寝忘食；其实这都没什么问题，但要注意生活和工作要分离开来，工作时跟要注重业务流程，团队协作与自己技术的点滴积累，同时认清自己的职业规划是管理走向还是技术走向。并且根据不同的规划，去有目的的培养自己充实自己。在生活中，除了摆弄摆弄自己的技术博客，研究下优秀代码，多多参与线下沙龙之外更要注重自己的身体，多锻炼，多健身。行万里路胜读万卷书，要喝热爱技术的小伙伴多去远方探讨技术和人生，不要将工作带到生活，不要局限在工作，而要将兴趣和快乐融入生活，充实自我，丰富自我。 </p><style type="text/css">    p {        text-indent: 2em    }</style>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/14/education/#disqus_thread</comments>
    </item>
    
    <item>
      <title>java关于时区的获取的几种方式</title>
      <link>https://blog.futuredream.top/2017/11/06/timeZone/</link>
      <guid>https://blog.futuredream.top/2017/11/06/timeZone/</guid>
      <pubDate>Mon, 06 Nov 2017 10:19:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;1.java8中基本只能通过当前位置所在城市名来获取时区&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div c
        
      
      </description>
      
      <content:encoded><![CDATA[<p>1.java8中基本只能通过当前位置所在城市名来获取时区<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//&lt;1&gt; 查看当前的时区</span></div><div class="line">ZoneId defaultZone = ZoneId.systemDefault();</div><div class="line">System.out.println(defaultZone); <span class="comment">//此处打印为时区所在城市Asia/Shanghai</span></div><div class="line"><span class="comment">//&lt;2&gt;查看美国纽约当前的时间</span></div><div class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</div><div class="line">LocalDateTime shanghaiTime = LocalDateTime.now(america);</div></pre></td></tr></table></figure><h4 id="如果是传入时间，又该如何计算时区呢？"><a href="#如果是传入时间，又该如何计算时区呢？" class="headerlink" title="如果是传入时间，又该如何计算时区呢？"></a>如果是传入时间，又该如何计算时区呢？</h4><p>2.使用SimpleDateFormat 来获取Date时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"Z"</span>);</div><div class="line">System.out.println(dateFormat.format(<span class="keyword">new</span> Date()));<span class="comment">//‘z’小写CST；'Z'大写+0800</span></div></pre></td></tr></table></figure><p>3.使用lang3中的org.apache.commons.lang3.time函数获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">System.out.println(DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"z"</span>));<span class="comment">//‘z’小写CST；'Z'大写 +0800</span></div><div class="line"></div><div class="line">System.out.println(DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"ZZ"</span>));<span class="comment">//'zz'小写一样 "ZZ"大写+08:00</span></div></pre></td></tr></table></figure><p>4.使用日历类来计算出传入时间所在时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Calendar cal = Calendar.getInstance();</div><div class="line">        <span class="keyword">int</span> offset = cal.get(Calendar.ZONE_OFFSET);</div><div class="line">        cal.add(Calendar.MILLISECOND, -offset);</div><div class="line">        Long timeStampUTC = cal.getTimeInMillis();</div><div class="line">        Long timeStamp = date.getTime();</div><div class="line">        Long timeZone = (timeStamp - timeStampUTC) / (<span class="number">1000</span> * <span class="number">3600</span>);</div><div class="line">        System.out.println(timeZone.intValue());<span class="comment">//8</span></div></pre></td></tr></table></figure><p>暂时总结出这几种。</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/11/06/timeZone/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Doker ELK 的安装部署使用教程</title>
      <link>https://blog.futuredream.top/2017/10/25/Doker_ELK/</link>
      <guid>https://blog.futuredream.top/2017/10/25/Doker_ELK/</guid>
      <pubDate>Tue, 24 Oct 2017 18:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;1-ELK是什么？&quot;&gt;&lt;a href=&quot;#1-ELK是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. ELK是
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-ELK是什么？"><a href="#1-ELK是什么？" class="headerlink" title="1. ELK是什么？"></a>1. ELK是什么？</h3><p>   ELK 是由Elasticsearch，Logstash 和 kibana 三个组件组成的 一种日志收集分析系统。</p><p>   其中：</p><ol><li>Logstash： 主要用来收集日志，并对日志进行分析，处理与储存，并将其发送给Elasticsearch</li><li>Elasticsearch： 为一开源的分布式搜索引擎 ，他可以为日志添加索引，对索引进行自动分片，提供良好的restful风格接口，提供自动的搜索负载等。</li><li>Kibana : 为该日志分析系统 提供web可视化的界面和可供查询编辑的各类分析视图等。</li></ol><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h3><p><img src="https://i.v2ex.co/2Zo3bPa3.png" alt="ELK工作流程"></p><p>Logstash从各个日志源进行日志的收集工作，并根据配置信息进行过滤，发送给Elasticsearch 添加索引，再由Kibana进行展示。</p><h3 id="3-选用-elk-docker-进行部署"><a href="#3-选用-elk-docker-进行部署" class="headerlink" title="3.选用 elk-docker 进行部署"></a>3.选用 elk-docker 进行部署</h3><p>在这里，选用 elk-docker 来进行容器的部署工作</p><ul><li>首先，使用 <code>sudo docker pull sebp/elk</code>  将相关 镜像 pull 下来；为什么使用 sebp/elk 是因为，他的文档写的 是最全面，最容易理解，<a href="http://elk-docker.readthedocs.io/" target="_blank" rel="noopener">文档</a>中包含了很多问题的解决办法；</li><li>安装前置条件：<ol><li>Docker至少得分配3GB的内存；</li><li>Elasticsearch至少需要单独2G的内存；</li><li>防火墙开放相关端口 这个可以查看<a href="http://elk-docker.readthedocs.io/" target="_blank" rel="noopener">文档</a>；</li><li><code>sudo vim /etc/sysctl.conf</code> 在该文件中添加 <code>vm.max_map_count = 262144</code> 然后执行命令 <code>sysctl -p</code> 查询修改是否成功</li></ol></li><li>安装 <ol><li>pull下docker镜像 其镜像的配置文件位于 <code>/etc/logstash/conf.d/</code> 文件夹下，他有几个配置文件 30-output.conf 为输出过滤，02-beats-input.conf 为输入过滤等等，可进行相应的配置替换；</li><li>如果替换的话，使用docker 的 -v 命令对 <code>/etc/logstash/conf.d/</code> 下的文件进行相应的替换。建议参考logstash的配置文档，先对logstash的配置有个初步的了解和认识。初次启动时建议按下面的方式进行启动，当成功启动后，进入docker容器，并进入<code>/etc/logstash/conf.d/</code> 下查看各个配置文件，您大概就知道如何进行配置工作了。</li><li>如果不替换 输入： <code>docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk</code>  接着进入容器内部 输入 <code>docker exec -it &lt;container-name&gt; /bin/bash</code> ，并执行命令：<code>/opt/logstash/bin/logstash -e &#39;input { stdin { } } output { elasticsearch { hosts =&gt; [&quot;localhost&quot;] } }&#39;</code> 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the “path.data” setting. 请执行命令：service logstash stop 然后在执行就可以了。当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=&gt;9600} 信息后，输入：this is a dummy entry 然后回车，模拟一条日志进行测试。</li><li>打开浏览器，输入：<a href="http://ip:5601" target="_blank" rel="noopener">http://ip:5601</a> 点击创建<br><img src="http://images2015.cnblogs.com/blog/1154245/201705/1154245-20170513171552754-2145153497.png" alt="创建方法"></li></ol></li></ul><p>如果你 Logstash 做了相应的 配置请在  <code>Index name or pattern</code> 中选对您的相应配置项 类似如下图中 我在<br>30-output.conf  中做了输出的数据时间头部的修改，所以就是如下图所示：</p><p><img src="http://img.blog.csdn.net/20171024173114928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjNva2Vy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="自我所示"></p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/10/25/Doker_ELK/#disqus_thread</comments>
    </item>
    
    <item>
      <title>行者 · 台灣 一</title>
      <link>https://blog.futuredream.top/2017/10/21/taiWan/</link>
      <guid>https://blog.futuredream.top/2017/10/21/taiWan/</guid>
      <pubDate>Fri, 20 Oct 2017 19:22:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;都可以随便，你说的，我都愿意去，小火车摆动的旋律。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h3&gt;&lt;hr&gt;
&lt;style t
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>都可以随便，你说的，我都愿意去，小火车摆动的旋律。</p></blockquote><h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><hr><style type="text/css">    p {        text-indent: 2em    }</style><p>時間如白駒過隙，不知不覺單身也有了些許時日。人雖走了，可是我的內心，卻未能放下。想想也是，何不趁著自己還年少，一個出去走走，散散心。</p><p>獨自來到深圳，平時工作繁忙，兩點一線之間疲於奔命。好不容易，回到了家，卻忽視了最愛人。也就十一有那麼些許空閒，我決定，一個出去走走。想到國內的熱門景點，只能看天上的雲流，和地上人流，肩併著肩，腳踏著腳，穿梭往來中，好不熱絡。想到這不如出去一片自由的土地–灣灣。特別是對於有來往台灣通行證，國慶去台灣算是個不錯的選擇。</p><h4 id="前往台灣前的準備"><a href="#前往台灣前的準備" class="headerlink" title="前往台灣前的準備"></a>前往台灣前的準備</h4><p>在一個中國的原則下，台灣現由中華民國政府實際管理。大陸遊客想要自由行去台灣，必須要求為開放城市或有該城市暫住證的居民才能申請赴台灣G簽證。其次，前往台灣之前需要向台灣移民局申請入台證，才可前往台灣。</p><p>我由於居住在深圳所以，很容易就能拿到G簽，而入台證方面呢，我在萬能的淘寶上，通過提交提供信用卡金卡掃描件，台灣通行證掃描件，身份證掃描件，和一寸證件照已經機酒行程規劃（只需要規劃即可）就順利的拿到了入台證。</p><p>當一切都準備好以後，便是出發了。機票我已經提前10天左右訂好的，10／03 - 10／09香港往返台北共一千八百元。在十一黃金週，算是很便宜了吧，而且飛機是國泰航空的波音787大型客機，客機餐點相對沒有國內航空的好吃，但是，可以在官網自主選擇適合自己的餐點。例如可以選擇穆斯林餐，全素食餐，印度教餐飲等，非常具有人性化，並且飛機上有一次性耳機，可獨立收看娛樂節目的小電視，不會干擾到其他人。酒店方面，由於自己是獨自出遊，全程選擇在airbnb預定青旅和民宿。</p><h4 id="前往香港國際機場"><a href="#前往香港國際機場" class="headerlink" title="前往香港國際機場"></a>前往香港國際機場</h4><p>因為想多休息一會，且又是住在蛇口，就決定從蛇口客運碼頭入境香港國際機場。船票一共270RMB，到香港後可退稅120HKD。大約半小時即可抵達，是最快抵達方式！</p><p style="text-align:center;"><br>    <img src="https://jokers-1252021562.cosgz.myqcloud.com/images/taiWan/%E8%9B%87%E5%8F%A3%E7%A2%BC%E9%A0%AD.JPG"><br>    <span>蛇口客運碼頭</span><br></p><p>在蛇口客運碼頭，就可辦理值機手續和托運行李，同時不需要使用港澳通行證，直接使用台灣通行證即可過關，是非常的方便和快捷的選擇，但是，必須要準備好來回的機票或船票行程單，否則過不去喔。當然，如果想圖便宜的話，從羅湖或福田口岸前往香港機場，是最便宜的，或者時間不著急，可以從這些口岸前往，並且還能夠去香港玩一玩。但卻十分的耗時。因為，如果從其他口岸入境，需要排隊填寫入境卡，並且還需要換乘以及先了解香港的交通路線。香港國際機場，很多免稅店，不要忘記買買買喔！</p><p style="text-align:center;"><br>    <img src="https://jokers-1252021562.cosgz.myqcloud.com/images/taiWan/HKAir.JPG"><br>    <span>香港赤鱲角國際機場時刻牌</span><br></p><p>香港赤鱲角國際機場曾在十二年內被英國航空評級機構Skytrax八度評為全球最佳機場，裡面的SKYCITY 航天城是與香港國際機場近在咫尺的大型綜合發展項目，佔地約25公頃。這個商業項目將結合零售、餐飲及娛樂設施、辦公大樓及酒店等，以滿足與日俱增的本地及海外旅客需求。總之，機場非常大，像我這種屌絲，就去萬寧，屈臣氏買了一些日化防曬用品，做最後的登機準備。</p><p>對喔，飛機是有可能提前飛，提前到的喔，這可是跟國內航班不一樣喔！</p><p>～～待續！</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/10/21/taiWan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随笔</title>
      <link>https://blog.futuredream.top/2017/10/13/farming1/</link>
      <guid>https://blog.futuredream.top/2017/10/13/farming1/</guid>
      <pubDate>Thu, 12 Oct 2017 20:42:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;买个番薯吧，否则也太寒冷。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;长期以来，我们都认为负面情绪是非常不好的，特别喜欢用转移疗法–要么就是与旁人倾诉，要么就是和外人发泄，而更多人则选择了强颜欢笑。&lt;/p&gt;
&lt;p&gt;其实，静下来想想，大部分
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>买个番薯吧，否则也太寒冷。</p></blockquote><hr><p>长期以来，我们都认为负面情绪是非常不好的，特别喜欢用转移疗法–要么就是与旁人倾诉，要么就是和外人发泄，而更多人则选择了强颜欢笑。</p><p>其实，静下来想想，大部分不高兴地河豚态，都是潜意识里的一个挣扎。你突然意识到现在的生活状态不对。或者总是起太晚，或者总是赚不到钱，或者，睁开眼睛总是看不到好的消息。就算是想有所行动或者改变，都觉得是狗咬月亮无处下嘴。</p><p>没有人可以精心策划适合所有人的自救方案。并且也不必。敢于承认自己今天不开心，敢于决定今天自己心情不好，已经很成熟了。两个解决办法：去街边买点吃的，或者关机独处。向外有人间烟火，向内则窥视内心。</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/10/13/farming1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>耕</title>
      <link>https://blog.futuredream.top/2017/10/12/farming/</link>
      <guid>https://blog.futuredream.top/2017/10/12/farming/</guid>
      <pubDate>Wed, 11 Oct 2017 20:42:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;春种一粒粟，秋收万颗子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或许是与我们是农耕民族有关吧，只要春天把种子种下，到了秋天就一定有收成。这种周而复始的自然规律，构成了我们特有的生活哲学。一种实用哲学 – 想要收获就去耕耘，没有结果的事，不要去尝
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>春种一粒粟，秋收万颗子。</p></blockquote><p>或许是与我们是农耕民族有关吧，只要春天把种子种下，到了秋天就一定有收成。这种周而复始的自然规律，构成了我们特有的生活哲学。一种实用哲学 – 想要收获就去耕耘，没有结果的事，不要去尝试。</p><p>当一个人除了本职工作以外，在其他方面表现平平，我们就会说这个人没什么本事；当一个人可以做很多事情时，我们又会说他不务正业。这就是唯结果论的我们，国人的实用哲学。可人生多些乐趣与多些结果，哪个更好呢?或许，这个简单的问题会烧死很多人的脑细胞。</p><p>新时代的4C人生，就是要敢于坚持自己梦想（Consistence）,即便有挫折也会充满信心(Confidence)，有勇气迎接任何挑战(Challenge)，尝试着去不断创新（Creativity），打破常规束缚，赢得充实的自我。</p><style type="text/css">    p {        text-indent: 2em    }</style>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/10/12/farming/#disqus_thread</comments>
    </item>
    
    <item>
      <title>路 · 我</title>
      <link>https://blog.futuredream.top/2017/10/11/streetSigns/</link>
      <guid>https://blog.futuredream.top/2017/10/11/streetSigns/</guid>
      <pubDate>Tue, 10 Oct 2017 19:22:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;我们好多人就像是路牌，站在路边给迷茫的人指引道路，自己却去不了想去的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;起&quot;&gt;&lt;a href=&quot;#起&quot; class=&quot;headerlink&quot; title=&quot;起&quot;&gt;&lt;/a&gt;起&lt;/h4&gt;&lt;p&gt;所有
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>我们好多人就像是路牌，站在路边给迷茫的人指引道路，自己却去不了想去的地方。</p></blockquote><h4 id="起"><a href="#起" class="headerlink" title="起"></a>起</h4><p>所有人，大抵上在自己有限的生命中都会追寻一件事情：寻找真我。寻找的方式和实现的途径也因人而异。中国人向来重视结果，只要能达到目的，过程是可以忽略的。但是，这和一个人毕生去寻找真我的过程是有些矛盾的，真我是随时可以实现，却又永远无法穷极的那个东西，它是一个无法完整却又真实存在的拼图。</p><p>徐静蕾曾说：”也许生命本身就带有不可避免的痛苦，既然免不了，不如尽量让自己快乐。如果思考导致了痛苦，那我宁可不要思考，尽可能做一些本能的选择”。而在真我之中，活出真我和实现真我又有着本质的区别，活出真我在于我们活着，在于活着的每分每秒，我们沐浴清风，聆听自然，影与光觥筹交错。但实现真我，却是一个听说过没见过的真实目标，在日常的点滴中，随心动，大觉大悟，大自在。</p><h4 id="落"><a href="#落" class="headerlink" title="落"></a>落</h4><p>半残岁月尽悠闲，半里乾坤开展。心情半佛半神仙，姓字半藏半显。半还天地，半留人间。</p><style type="text/css">    p {        text-indent: 2em    }</style>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/10/11/streetSigns/#disqus_thread</comments>
    </item>
    
    <item>
      <title>springboot填坑之 -- spring cloud基于ip的discovery服务注册中心配置</title>
      <link>https://blog.futuredream.top/2017/07/30/discovery1/</link>
      <guid>https://blog.futuredream.top/2017/07/30/discovery1/</guid>
      <pubDate>Sat, 29 Jul 2017 20:07:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;spring-cloud基于ip的discovery服务注册中心配置&quot;&gt;&lt;a href=&quot;#spring-cloud基于ip的discovery服务注册中心配置&quot; class=&quot;headerlink&quot; title=&quot;spring cloud基于ip的discove
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="spring-cloud基于ip的discovery服务注册中心配置"><a href="#spring-cloud基于ip的discovery服务注册中心配置" class="headerlink" title="spring cloud基于ip的discovery服务注册中心配置"></a>spring cloud基于ip的discovery服务注册中心配置</h2><p><code>SpringBoot</code>  <code>springCloud</code></p><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，集群状态）。分布式系统的协调导致锅炉板模式，并且使用Spring Cloud开发人员可以快速站起来实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。– <a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">引用自springCloud官网</a> </p></blockquote><hr><p>spring cloud 的注册中心的配置(包括其他的微服务的配置) 都是基于host进行配置的 会产生极大的不变 – 特别是在基于不同网段, 不同网关的 docker 容器之中 host的地址可能会不断变化,且 host不如ip容易维护.</p><p>综上所述: 本文将 聊一聊基于ip的注册中心的配置;</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">server:</div><div class="line">  port: 8761</div><div class="line">eureka:</div><div class="line">  instance:</div><div class="line">    lease-expiration-duration-in-seconds: 30 //1</div><div class="line">    lease-renewal-interval-in-seconds: 10 //2</div><div class="line">    prefer-ip-address: true //3</div><div class="line">    ip-address: 114.114.114.xxx //4</div><div class="line">  server:</div><div class="line">    enable-self-preservation: false</div><div class="line">    eviction-interval-timer-in-ms: 1200000</div><div class="line">  client:</div><div class="line">    register-with-eureka: false //5</div><div class="line">    fetch-registry: false //6</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://$&#123;eureka.instance.ip-address&#125;:$&#123;server.port&#125;/eureka/  //7</div></pre></td></tr></table></figure><hr><h3 id="现在-来说明下"><a href="#现在-来说明下" class="headerlink" title="现在 来说明下:"></a>现在 来说明下:</h3><blockquote><ul><li><p>首先  1, 2  用来检测 服务是否存在 是否过期的</p><p>(1) 指注册中心在接收到最后一个心跳之后等待的时间（秒），然后才能从此视图中删除此实例，并禁止此实例的流量。<br>(2) 指注册的客户端服务需要向注册中心发送心跳以指示它仍然存在的频率（以秒为单位）。如果在leaseExpirationDurationInSeconds中指定的时间段内未收到心跳线，则eureka服务器将从其视图中删除该实例，因此不允许此实例的流量。</p></li><li><p>其次  (3)用来 开启 是否使用ip识别服务 当该变量为 <code>true</code> 时 此时 将会使用您的 内网ip去注册服务, 当您的服务注册中心是基于内网的服务,那么 配置服务到这一步即可.但是如果您的各项自服务,不再同一个网段中时, 请继续配置(4)</p></li><li><p>当您配置 (4) 时 即为手动配置ip地址注册服务, 此时 [3] 的配置将无效, 如果ip为指定注册中心所在的公网ip,那么 该注册中心将在公网可见.</p></li><li><p>当为单注册中心时, 做为注册中心,本服务当然不能注册自己 (5) ,(6) 配置为 false 服务才可以正常启动,当为多注册中心时(5) (6) 可不配置,但是(7)必须配置为<strong><em>非己</em></strong> 的url地址</p></li></ul></blockquote><hr>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/07/30/discovery1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git项目拆迁</title>
      <link>https://blog.futuredream.top/2017/07/29/git_move/</link>
      <guid>https://blog.futuredream.top/2017/07/29/git_move/</guid>
      <pubDate>Sat, 29 Jul 2017 11:24:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;本文摘自 &lt;a href=&quot;http://www.bijishequ.com/detail/260740?p=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.bijishequ.com/detail/260740?p=&lt;/a&gt;&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文摘自 <a href="http://www.bijishequ.com/detail/260740?p=" target="_blank" rel="noopener">http://www.bijishequ.com/detail/260740?p=</a></p><p>目的：</p><p>将项目在不同的git服务器上进行转移（coding &lt;—&gt; github等）<br>保留所有代码（包括分支）<br>保留提交记录<br>说明：</p><p>将项目从coding.net上面拆迁到github上（或者反过来迁到其他的git服务器 上，方法大致相同）<br>参考文章：<br>Coding.net使用和从Github转移项目到Coding.net<br>操作方法：</p><p>说明：</p><p>我采用的是从coding.net —&gt; 迁移到 github上面<br>步骤：</p><p>git clone –bare git@git.coding.net<em>.git（git 要迁移的项目），会生成 </em>.git项目<br>cd 进入生成的项目 <em>.git 下面<br>git push –mirror git@github.com:</em>.git（需要迁移到的git服务器上面的一个空的项目）<br>大功告成！</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/07/29/git_move/#disqus_thread</comments>
    </item>
    
    <item>
      <title>springBoot填坑手册二 redis与cache之坑</title>
      <link>https://blog.futuredream.top/2017/07/29/redis1/</link>
      <guid>https://blog.futuredream.top/2017/07/29/redis1/</guid>
      <pubDate>Sat, 29 Jul 2017 11:24:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;spring-Boot-填坑手册-redis与cache之坑&quot;&gt;&lt;a href=&quot;#spring-Boot-填坑手册-redis与cache之坑&quot; class=&quot;headerlink&quot; title=&quot;spring Boot 填坑手册 redis与cache之坑&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="spring-Boot-填坑手册-redis与cache之坑"><a href="#spring-Boot-填坑手册-redis与cache之坑" class="headerlink" title="spring Boot 填坑手册 redis与cache之坑"></a>spring Boot 填坑手册 redis与cache之坑</h3><p>在处理高并发时,我们常常用到缓存,首先,说说redis的配置,与注意事项.</p><blockquote><p>在pom.xml中需要引入spring-boot-starter-data-redis和spring-boot-starter-cache 如此引入之后,缓存配置就默认为redis,配置redis 需要在application.properties中配置如下参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#redis</div><div class="line">spring.redis.database=1 ## 可选</div><div class="line">spring.redis.host=192.168.99.100</div><div class="line">spring.redis.port=6379</div><div class="line">spring.redis.pool.max-active=1024  ## 可选</div><div class="line">spring.redis.pool.max-wait=1000 ## 可选</div><div class="line">spring.redis.pool.max-idle=200 ## 可选</div></pre></td></tr></table></figure><p>这时大抵上redis就配置好了<br>redis本身给我们了 RedisTemplate 和 StringRedisTemplate 两块模版 ,实现对redis的操作 ,<br>这里面一定要注意 , 当使用 opsForValue() 来set对象时 ,首先 RedisTemplate 序列化对象会使用JDK的对象序列化 , 所以该对象一定要实现 Serializable (网上有推荐使用jackson做序列化的方法,并不推荐, 因为使用JDK本身的序列化可得到二进制字符 , 高效快速。)<br>其次，当opsXXX()来get对象时 , RedisTemplate 和 StringRedisTemplate 要区分开 , 否则得不到想要的结果 .</p><blockquote><p>接下来说缓存 , 这里因为使用了redis所以系统会默认redis做缓存, 如果想要redis做别的事情,而用别的缓存框架,该怎么办??</p></blockquote><p>1.那么首先 , 需要在application.properties中配置如下参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#Cache</div><div class="line">spring.cache.type=guava #指明所用的缓存架构,我这里用的 guava </div><div class="line">spring.cache.cache-names[0]=outsourced # 指明缓存库的名称</div></pre></td></tr></table></figure><ol><li>在pom.xml中需要引入对应的缓存工具<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;guava&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;19.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></li></ol><p>3.对应缓存实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override                                      //key 缓存的键名 &apos;#&apos;不能少</div><div class="line">@Cacheable(value = &quot;outsourced&quot;, key = &quot;#name&quot;)//value 指缓存库的名称</div><div class="line">public UserInfo fineOne(String name) &#123;</div><div class="line">    UserInfo userInfo = userInfoRepository.findFirstByUserName(&quot;樱桃&quot;);</div><div class="line">    System.out.print(&quot;缓存了key为&quot;+name+&quot;的鬼&quot;);</div><div class="line">    return userInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完</p><hr><p>后续更新：</p><p>文章中写的不太好，应该是不推荐使用JDK来做二进制缓存，JDK自带的序列化工具出来的二进制过长，再分布式环境，特别是跨语言的环境，推荐使用Thrift、Protobuf和Avro 等序列化通信解决方案，他们能友好的规避，XML体积太大，解析性能极差；JSON体积相对较小，解析相对较快，但表达能力较弱的特点。<br>当然，json对人来说的可读性较好，能如果想使用jackson2.x做缓存，可在redisTemplate中配置setKeySerializer/setValueSerializer/setHashValueSerializer等的序列化方式，这里使<code>GenericJackson2JsonRedisSerializer</code> 类来进行配置，具体配置可参考如下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    @Resource</div><div class="line">    private RedisProperties redisProperties;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public JedisPoolConfig jedisPoolConfig() &#123;</div><div class="line">        JedisPoolConfig config = new JedisPoolConfig();</div><div class="line">        config.setMaxIdle(10);</div><div class="line">        config.setMaxTotal(100);</div><div class="line">        config.setMaxWaitMillis(5000);</div><div class="line">        config.setMinIdle(0);</div><div class="line">        config.setTestOnBorrow(true);</div><div class="line">        config.setTestWhileIdle(true);</div><div class="line">        config.setNumTestsPerEvictionRun(2);</div><div class="line">        config.setTimeBetweenEvictionRunsMillis(30000);</div><div class="line">        config.setMinEvictableIdleTimeMillis(60000);</div><div class="line">        config.setSoftMinEvictableIdleTimeMillis(60000);</div><div class="line">        return config;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RedisConnectionFactory redisConnectionFactory() &#123;</div><div class="line">        JedisConnectionFactory redisConnectionFactory = new JedisConnectionFactory(jedisPoolConfig());</div><div class="line">        redisConnectionFactory.setDatabase(redisProperties.getDatabase());</div><div class="line">        redisConnectionFactory.setHostName(redisProperties.getHost());</div><div class="line">        redisConnectionFactory.setPort(redisProperties.getPort());</div><div class="line">        redisConnectionFactory.setPassword(redisProperties.getPassword());</div><div class="line">        redisConnectionFactory.setTimeout(15000);</div><div class="line">        redisConnectionFactory.setUsePool(true);</div><div class="line">        return redisConnectionFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public &lt;K, V&gt; RedisTemplate&lt;K, V&gt; redisTemplate() &#123;</div><div class="line">        RedisTemplate&lt;K, V&gt; template = new RedisTemplate&lt;&gt;();</div><div class="line">        template.setConnectionFactory(redisConnectionFactory());</div><div class="line">        template.setKeySerializer(new StringRedisSerializer());</div><div class="line">        template.setHashKeySerializer(new StringRedisSerializer());</div><div class="line">        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());</div><div class="line">        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());</div><div class="line">//        template.setEnableTransactionSupport(true);</div><div class="line">        template.afterPropertiesSet();</div><div class="line">        return template;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>特别强调：推荐使用 GenericJackson2JsonRedisSerializer 去替代 Jackson2JsonRedisSerializer<object>以及JacksonJsonRedisSerializer<object><br>因为GenericJackson2JsonRedisSerializer 可以保留泛型。<br>在处理高并发时,我们常常用到缓存,首先,说说redis的配置,与注意事项.</object></object></p><blockquote><p>在pom.xml中需要引入spring-boot-starter-data-redis和spring-boot-starter-cache 如此引入之后,缓存配置就默认为redis,配置redis 需要在application.properties中配置如下参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#redis</div><div class="line">spring.redis.database=1 ## 可选</div><div class="line">spring.redis.host=192.168.99.100</div><div class="line">spring.redis.port=6379</div><div class="line">spring.redis.pool.max-active=1024  ## 可选</div><div class="line">spring.redis.pool.max-wait=1000 ## 可选</div><div class="line">spring.redis.pool.max-idle=200 ## 可选</div></pre></td></tr></table></figure><p>这时大抵上redis就配置好了<br>redis本身给我们了 RedisTemplate 和 StringRedisTemplate 两块模版 ,实现对redis的操作 ,<br>这里面一定要注意 , 当使用 opsForValue() 来set对象时 ,首先 RedisTemplate 序列化对象会使用JDK的对象序列化 , 所以该对象一定要实现 Serializable (网上有推荐使用jackson做序列化的方法,并不推荐, 因为使用JDK本身的序列化可得到二进制字符 , 高效快速。)<br>其次，当opsXXX()来get对象时 , RedisTemplate 和 StringRedisTemplate 要区分开 , 否则得不到想要的结果 .</p><blockquote><p>接下来说缓存 , 这里因为使用了redis所以系统会默认redis做缓存, 如果想要redis做别的事情,而用别的缓存框架,该怎么办??</p></blockquote><p>1.那么首先 , 需要在application.properties中配置如下参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#Cache</div><div class="line">spring.cache.type=guava #指明所用的缓存架构,我这里用的 guava </div><div class="line">spring.cache.cache-names[0]=outsourced # 指明缓存库的名称</div></pre></td></tr></table></figure><ol><li>在pom.xml中需要引入对应的缓存工具<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;guava&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;19.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></li></ol><p>3.对应缓存实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override                                      //key 缓存的键名 &apos;#&apos;不能少</div><div class="line">@Cacheable(value = &quot;outsourced&quot;, key = &quot;#name&quot;)//value 指缓存库的名称</div><div class="line">public UserInfo fineOne(String name) &#123;</div><div class="line">    UserInfo userInfo = userInfoRepository.findFirstByUserName(&quot;樱桃&quot;);</div><div class="line">    System.out.print(&quot;缓存了key为&quot;+name+&quot;的鬼&quot;);</div><div class="line">    return userInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完</p><hr><p>后续更新：</p><p>文章中写的不太好，应该是不推荐使用JDK来做二进制缓存，JDK自带的序列化工具出来的二进制过长，再分布式环境，特别是跨语言的环境，推荐使用Thrift、Protobuf和Avro 等序列化通信解决方案，他们能友好的规避，XML体积太大，解析性能极差；JSON体积相对较小，解析相对较快，但表达能力较弱的特点。<br>当然，json对人来说的可读性较好，能如果想使用jackson2.x做缓存，可在redisTemplate中配置setKeySerializer/setValueSerializer/setHashValueSerializer等的序列化方式，这里使<code>GenericJackson2JsonRedisSerializer</code> 类来进行配置，具体配置可参考如下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    @Resource</div><div class="line">    private RedisProperties redisProperties;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public JedisPoolConfig jedisPoolConfig() &#123;</div><div class="line">        JedisPoolConfig config = new JedisPoolConfig();</div><div class="line">        config.setMaxIdle(10);</div><div class="line">        config.setMaxTotal(100);</div><div class="line">        config.setMaxWaitMillis(5000);</div><div class="line">        config.setMinIdle(0);</div><div class="line">        config.setTestOnBorrow(true);</div><div class="line">        config.setTestWhileIdle(true);</div><div class="line">        config.setNumTestsPerEvictionRun(2);</div><div class="line">        config.setTimeBetweenEvictionRunsMillis(30000);</div><div class="line">        config.setMinEvictableIdleTimeMillis(60000);</div><div class="line">        config.setSoftMinEvictableIdleTimeMillis(60000);</div><div class="line">        return config;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RedisConnectionFactory redisConnectionFactory() &#123;</div><div class="line">        JedisConnectionFactory redisConnectionFactory = new JedisConnectionFactory(jedisPoolConfig());</div><div class="line">        redisConnectionFactory.setDatabase(redisProperties.getDatabase());</div><div class="line">        redisConnectionFactory.setHostName(redisProperties.getHost());</div><div class="line">        redisConnectionFactory.setPort(redisProperties.getPort());</div><div class="line">        redisConnectionFactory.setPassword(redisProperties.getPassword());</div><div class="line">        redisConnectionFactory.setTimeout(15000);</div><div class="line">        redisConnectionFactory.setUsePool(true);</div><div class="line">        return redisConnectionFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public &lt;K, V&gt; RedisTemplate&lt;K, V&gt; redisTemplate() &#123;</div><div class="line">        RedisTemplate&lt;K, V&gt; template = new RedisTemplate&lt;&gt;();</div><div class="line">        template.setConnectionFactory(redisConnectionFactory());</div><div class="line">        template.setKeySerializer(new StringRedisSerializer());</div><div class="line">        template.setHashKeySerializer(new StringRedisSerializer());</div><div class="line">        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());</div><div class="line">        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());</div><div class="line">//        template.setEnableTransactionSupport(true);</div><div class="line">        template.afterPropertiesSet();</div><div class="line">        return template;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>特别强调：推荐使用 GenericJackson2JsonRedisSerializer 去替代 Jackson2JsonRedisSerializer<object>以及JacksonJsonRedisSerializer<object><br>因为GenericJackson2JsonRedisSerializer 可以保留泛型。</object></object></p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/07/29/redis1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>spring使用@Value标签读取.properties文件的中文乱码问题的解决</title>
      <link>https://blog.futuredream.top/2017/06/28/value/</link>
      <guid>https://blog.futuredream.top/2017/06/28/value/</guid>
      <pubDate>Wed, 28 Jun 2017 09:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;$begin$&lt;/p&gt;
&lt;h3 id=&quot;spring使用-Value标签读取-properties文件的中文乱码问题的解决&quot;&gt;&lt;a href=&quot;#spring使用-Value标签读取-properties文件的中文乱码问题的解决&quot; class=&quot;headerlink&quot; ti
        
      
      </description>
      
      <content:encoded><![CDATA[<p>$begin$</p><h3 id="spring使用-Value标签读取-properties文件的中文乱码问题的解决"><a href="#spring使用-Value标签读取-properties文件的中文乱码问题的解决" class="headerlink" title="spring使用@Value标签读取*.properties文件的中文乱码问题的解决"></a>spring使用@Value标签读取*.properties文件的中文乱码问题的解决</h3><p><code>spring</code> <code>中文乱码</code> <code>@Value</code> <code>*.properties</code></p><hr><p>在spring中我们常常使用.properties对一些属性进行一个提前配置, spring 在读取*.properties文件时,默认使用的是asci码, 这时 我们需要对其编码进行转换.  当然 方法有很多种 ,我说以下几种</p><hr><blockquote><p>1.$在配置spring.xml文件时,声明所需的*.properties文件时直接使用”utf-8”编码$<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:conf/*.properties"</span> <span class="attr">file-encoding</span>=<span class="string">"UTF-8"</span>/&gt;</span></div></pre></td></tr></table></figure></p><p>2.$ 如果在所需类上注入 可使用以下方式来声明编码格式:$</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"classpath:conf/copyWriteUI.properties"</span>,encoding = <span class="string">"utf-8"</span>)</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyWriteUI</span> </span>&#123;</div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;a&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String a;</div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;b&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String b;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>3.$不设置编码格式, 编写文件时 将中文转化为unicode编码$</p><ol><li>$如果你用的是IntelliJ IDEA 那么 按如下图操作以上步揍都可以省去啦!!! idea 会自动帮我们进行如上的第三步,解放了我们的双手!$<br><img src="http://img.blog.csdn.net/20161223170843818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjNva2Vy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="idea 会自动帮我们进行如上的第三步的"></li></ol></blockquote><h3 id="附录-spring-lt-context-property-placeholder-gt-的属性说明"><a href="#附录-spring-lt-context-property-placeholder-gt-的属性说明" class="headerlink" title="附录  spring &lt;context:property-placeholder/&gt; 的属性说明"></a>附录  spring <code>&lt;context:property-placeholder/&gt;</code> 的属性说明</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span>   </span></div><div class="line"><span class="tag">        <span class="attr">location</span>=<span class="string">"属性文件，多个之间逗号分隔"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">file-encoding</span>=<span class="string">"文件编码"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">ignore-resource-not-found</span>=<span class="string">"是否忽略找不到的属性文件"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">ignore-unresolvable</span>=<span class="string">"是否忽略解析不到的属性，如果不忽略，找不到将抛出异常"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">properties-ref</span>=<span class="string">"本地Properties配置"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">local-override</span>=<span class="string">"是否本地覆盖模式，即如果true，那么properties-ref的属性将覆盖location加载的属性，否则相反"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">system-properties-mode</span>=<span class="string">"系统属性模式，默认ENVIRONMENT（表示先找ENVIRONMENT，再找properties-ref/location的），NEVER：表示永远不用ENVIRONMENT的，OVERRIDE类似于ENVIRONMENT"</span>  </span></div><div class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">"顺序"</span>  </span></div><div class="line"><span class="tag">        /&gt;</span></div></pre></td></tr></table></figure><p>$end$</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/06/28/value/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nginx代理TCP模块</title>
      <link>https://blog.futuredream.top/2017/06/28/nginx_tcp/</link>
      <guid>https://blog.futuredream.top/2017/06/28/nginx_tcp/</guid>
      <pubDate>Wed, 28 Jun 2017 09:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;nginx1-9之后的版本可代理TCP链接&quot;&gt;&lt;a href=&quot;#nginx1-9之后的版本可代理TCP链接&quot; class=&quot;headerlink&quot; title=&quot;nginx1.9之后的版本可代理TCP链接&quot;&gt;&lt;/a&gt;nginx1.9之后的版本可代理TCP链接&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="nginx1-9之后的版本可代理TCP链接"><a href="#nginx1-9之后的版本可代理TCP链接" class="headerlink" title="nginx1.9之后的版本可代理TCP链接"></a>nginx1.9之后的版本可代理TCP链接</h4><ol><li>其中Windows版本可直接使用</li><li>Linux版本需要在编译(./configure)时添加–with-stream参数</li><li>简单 示例如下</li></ol><p>1.简单代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">server &#123;</div><div class="line">listen 22;</div><div class="line">proxy_connect_timeout 20s;</div><div class="line">proxy_timeout 2m;</div><div class="line">proxy_pass ip:port;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.负载均衡 操作与Http代理非常的类似 下面是一个官方Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    upstream backend &#123;</div><div class="line">        hash $remote_addr consistent;</div><div class="line">        server backend1.example.com:12345 weight=5;</div><div class="line">        server 127.0.0.1:12345 max_fails=3 fail_timeout=30s;</div><div class="line">        server unix:/tmp/backend3;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        proxy_connect_timeout 1s;</div><div class="line">        proxy_timeout 3s;</div><div class="line">        proxy_pass backend;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    server &#123;</div><div class="line">        listen [::1]:12345;</div><div class="line">        proxy_pass unix:/tmp/stream.socket;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/06/28/nginx_tcp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Druid Spring Boot Starter数据库链接池新福利</title>
      <link>https://blog.futuredream.top/2017/06/28/druid/</link>
      <guid>https://blog.futuredream.top/2017/06/28/druid/</guid>
      <pubDate>Wed, 28 Jun 2017 08:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;druid-spring-boot-starter-1-1版本发布&quot;&gt;&lt;a href=&quot;#druid-spring-boot-starter-1-1版本发布&quot; class=&quot;headerlink&quot; title=&quot;druid-spring-boot-starter 
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="druid-spring-boot-starter-1-1版本发布"><a href="#druid-spring-boot-starter-1-1版本发布" class="headerlink" title="druid-spring-boot-starter 1.1版本发布"></a>druid-spring-boot-starter 1.1版本发布</h4><p>Druid 与spingBoot的完美整合由阿里官方发布了,作为最好最快最稳定的数据库连接池,现在有了springBoot版本,真好.<br>官方gitHub文档链接: <a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" target="_blank" rel="noopener">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a><br>内附有maven地址.</p><p>完</p>]]></content:encoded>
      
      <comments>https://blog.futuredream.top/2017/06/28/druid/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
